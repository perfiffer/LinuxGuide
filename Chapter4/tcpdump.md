tcpdump是一个基于Unix系统的命令行式的数据包嗅探工具，可以抓取流动在网卡上的数据包。

tcpdump支持针对网络层，协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。

Linux下的抓包原理：通过注册一种虚拟的底层网络协议来完成对网络报文（准确的说是网络设备）消息的处理权。当网卡接收到一个网络报文之后，会遍历系统中所有已经注册的网络协议，如以太网协议、x25协议处理模块来尝试进行报文的解析处理，这一点和一些文件系统的挂载相似，就是让系统中所有的已经注册的文件系统来进行尝试挂载，如果哪一个认为自己可以处理，那么就完成挂载。  
当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块。  

默认情况下，tcpdump不会抓取本机内部通讯的报文。根据网络协议栈的规定，对于报文，即使目的地是本机，也需要经过本机的网络协议层，所以本机通讯肯定是通过API进入了内核，并且完成了路由选择。  

如果要使用tcpdump抓取其他主机MAC地址的数据包，必须开启网卡混杂模式，所谓混杂模式，就是让网卡抓取任何经过它的数据包，不管这个数据包是不是发给它或者由它发出的。  

一般而言，Unix不会让普通用户设置混杂模式，因为这样会有信息暴露的风险，引起安全问题。只有root用户可以开启混杂模式，命令是：ifconfig eth0 promisc，eth0是要开启混杂模式的网卡。

## 0x01 安装
>默认情况下，Linux系统都自带了tcpdump，可以使用tcpdump -h命令查看。如果未安装，可以使用以下方式安装。

```
#Redhat系列
yum -y install tcpdump
#Debain系列
apt-get install tcpdump
```
## 0x02 语法
```
tcpdump [-aAbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ]
        [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]
        [ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]
        [ -Q|-P in|out|inout ]	
        [ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]
        [ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]
        [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]
        [ -Z user ] [ expression ]
```

## 0x03 常用参数
```
-A: 以ASCII码打印每个报文（不包括链路层的头），适用于分析网页
-b: 以ASDOT方式代替ASPLAIN方式打印BGP包中的AS号
-B buffer_size: 设置操作系统抓包缓冲区大小为buffer_size，单位为KB
-a: 将网络地址和广播地址转变成名字
-c: 指定抓包数量，在收到指定的包数目后，tcpdump就会停止
-C file_size: 用于判断-w选项将报文写入的文件大小是否超过file_size指定的值，如果超过了就新建文件（文件名后缀按照1，2，3...依次增加） 
-d: 将匹配信息包的代码以汇编格式输出
-dd: 将匹配信息包的代码以C语言程序段的格式输出
-ddd: 将匹配信息包的代码以十进制的格式输出
-D: 列出当前主机的所有网卡编号和名称，可以用于选项-i
-e: 在输出行打印出数据链路层的头部信息
-f: 将外部的internet地址以数字的形式打印出来
-F: 从指定的文件中读取表达式，忽略其它的表达式
-G rotate_seconds: 每隔rotate_seconds秒将会轮转使用-w选项指定的转储文件。保存的文件名是由-w选项指定的，文件名中包含格式化的时间，如果没有指定时间格式，每个文件都将覆盖前一个文件 
-h: 输出tcpdump的版本信息和libpcap的版本信息，并输出tcpdump的命令使用格式
-i interface: 监听主机的指定网卡的数据流，如-i eth0，监听eth0网卡的数据流。如果没有指定，会使用编号最小的网卡（通过-D选项查看，但是不包括环回接口），Linux2.2及之后的内核版本支持any参数，可以监听任意网卡
-l: 将报文以行的方式打印到标准输出
-L: 以指定模式列出接口的已知数据链接类型并退出。已知数据的列表链接类型可能依赖于指定的模式
-n: 显示ip，不显示主机名，可以避免DNS查找
-nn: 不显示协议和端口信息
-N: 不显示域名
-#：在行首打印可选的包号，同--number 
-O: 不运行包匹配代码优化器
-p: 不让网络界面接入混杂模式
-Q|-P direction: 选择发送/接收捕获数据包的方向，可选direction值有in，out。部分平台可用
-q: 快速退出，仅列出少数的传输协议信息
-r file: 从指定的文件中读取包（一般是通过-w选项产生的）
-S: 打印TCP序列号的绝对值，而不是相对值
-s snaplen: 指定抓包显示一行的宽度，-s0表示可按包长显示完整的包，经常和—A一起使用，默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数会导致数据包丢失
-t: 在输出的每一行不打印时间戳
-tt: 在输出的每一行打印未经格式化的时间戳
-ttt: 在输出的每一行打印当前行与上一行之间的差值（微秒分辨率）
-tttt: 在输出的每一行日期之前打印从午夜开始的时间戳（小时、分钟、秒和几分之一秒）
-ttttt: 在输出的每一行之前打印当前行和第一行之间的差值（微秒分辨率）
-T type: 将监听到的包直接解释为指定类型的报文，常见的有rpc（远程过程调用）和snmp（简单网络管理协议）
-v: 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型信息
-vv: 输出详细的报文信息
-x: 解析和打印时，除了打印每个包的头外，还打印每个包的数据（减去它的链路头），以十六进制方式输出
-xx: 解析和打印时，除了打印每个包的头外，还打印每个的数据，包括链路头，以十六进制方式输出
-X: 解析和打印时，除了打印每个数据包的头外，还打印每个包的数据（减去链路头），以十六进制和ASCII编码的方式输出
-XX: 解析和打印时，除了打印每个数据包的头外，还打印每个包的数据，包括链路头，以十六进制和ASCII编码的方式输出
-w file: 直接将包写入指定的file文件中
expression: 用于过滤输出结果的逻辑表达式 
```

## 0x03 使用示例



